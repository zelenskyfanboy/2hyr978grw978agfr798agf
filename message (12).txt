-- run_on_actor(getactors()[1], readfile("ragobogot.lua"))

local scanPositions = true
local fireposRadius = 9 -- max 10 studs
local scanHitPositions = true
local hitboxRadius = 5 -- max 9 studs

local teleportScanning = false -- BROKEN
local maxTeleportRadius = 16 -- max 20 studs
local teleportingFireposRadius = 8 -- max 16 studs
local teleportingHitboxRadius = 8 -- max 10 studs

local firerateBypass = true
local fireDelayMS = 350 -- min 300 with tp scanning

local ambient = false
local ambientColor = Color3.fromRGB(255, 0, 255)

local drawTrajectory = true -- for damagehaxx
local lineThickness = 0.8
local lineMaterial = "ForceField"
local lineTransparency = 0.5
local lineColor = Color3.fromRGB(220, 92, 255)
local lineDuration = 3
local lineFadeDuration = 1

local ragebotScanFPS = 60
local ragebotPositionScanCount = 8 -- turn this down if you are lagging a lot (minimum 1)
local ragebotTeleportScanCount = 4
local raycastingMode = "performance" -- "accurate" or "performance"
local missCooldownMS = 500
local undetected = false -- shitty

local oldData = (unload and unload()) or {}
local shared = getrenv().shared
local roundSystem = shared.require("RoundSystemClientInterface")
local weapon = shared.require("WeaponControllerInterface")
local replication = shared.require("ReplicationInterface")
local hudnotify = shared.require("HudNotificationConfig")
local publicSettings = shared.require("PublicSettings")
local bulletObject = shared.require("BulletObject")
local bulletCheck = shared.require("BulletCheck")
local weaponUtils = shared.require("WeaponUtils")
local network = shared.require("NetworkClient")

local userInputService = game:GetService("UserInputService")
local runService = game:GetService("RunService")
local workspace = game:GetService("Workspace")
local lighting = game:GetService("Lighting")
local players = game:GetService("Players")

hudnotify.typeList.kill[1] = "Furry Killed!"
local acceleration = Vector3.new(0, -workspace.Gravity, 0)
local localPlayer = players.LocalPlayer
local ignore = workspace.Ignore
local tracerFolder = Instance.new("Folder", ignore)
local bulletCount = oldData.bulletCount or 1
local currentAddition = oldData.currentAddition or 0
local scanDirections = {
    front = Vector3.new(0, 0, -1),
    bottom = Vector3.new(0, -1, 0),
    top = Vector3.new(0, 1, 0),
    right = Vector3.new(1, 0, 0),
    left = Vector3.new(-1, 0, 0)
}
local timeUpdates = {
    equip = 2,
    newbullets = 3,
    bullethit = 6,
    knifehit = 4,
    newgrenade = 3,
    spotplayers = 2,
    updatesight = 3,
}

local function trajectory(o, a, t, s)
    local f = -a
    local ld = t - o
    local a = f:Dot(f)
    local b = 4 * ld:Dot(ld)
    local k = (4 * (f:Dot(ld) + s * s)) / (2 * a)
    local v = (k * k - b / a) ^ 0.5
    local t, t0 = k - v, k + v

    t = t < 0 and t0 or t; t = t ^ 0.5
    return f * t / 2 + ld / t, t
end

local function toanglesyx(v)
	local x, y, z = v.x, v.y, v.z
	return math.asin(y / (x * x + y * y + z * z) ^ 0.5), math.atan2(-x, -z)
end

local ignoredPlayers = {}
local shooting = {}
local function getClosestPlayers(position)
    local closestCharacters
    local characterData

    replication.operateOnAllEntries(function(player, entry)
        local character = entry._thirdPersonObject and entry._thirdPersonObject._characterHash

        if not ignoredPlayers[player] and not shooting[player] and entry._receivedPosition and entry._velspring.t and character and player.Team ~= localPlayer.Team and character.Head then
            local playerDistance = (character.Head.Position - position).Magnitude
            local playerData = {character, playerDistance}
            
            if not characterData then
                characterData = {playerData}
                closestCharacters = {entry}
            else
                for charIndex = #characterData, 1, -1 do
                    if playerDistance > characterData[charIndex][2] then
                        table.insert(characterData, charIndex + 1, playerData)
                        table.insert(closestCharacters, charIndex + 1, entry)
                        break
                    end
                end

                if not table.find(characterData, playerData) then
                    table.insert(characterData, 1, playerData)
                    table.insert(closestCharacters, 1, entry)
                end
            end
        end
    end)

    return closestCharacters
end

local physicsignore = {workspace.Terrain, workspace.Ignore, workspace.Players, workspace.Camera}
local raycastparameters = RaycastParams.new()
local function raycast(origin, direction, filterlist, whitelist)
    raycastparameters.IgnoreWater = true
    raycastparameters.FilterDescendantsInstances = filterlist or physicsignore
    raycastparameters.FilterType = Enum.RaycastFilterType[whitelist and "Whitelist" or "Blacklist"]

    local result = workspace:Raycast(origin, direction, raycastparameters)
    return result and result.Instance, result and result.Position, result and result.Normal
end

local raycastDelta = 1 / (raycastingMode == "performance" and 30 or 60)
local function getFirePositions(origin, target, bulletspeed, penetrationdepth, fireRadius, hitRadius)
    if scanPositions then
        local cframe = CFrame.new(origin, target) * CFrame.Angles(0, 0, math.rad(math.random(0, 90)))
        local reverse = CFrame.new(target, origin) * CFrame.Angles(0, 0, math.rad(math.random(0, 90)))
    
        for _, fireposOffset in next, scanDirections do
            local firepos = cframe * (fireposOffset * (fireRadius * 0.99))
            
            if scanHitPositions then
                for _, hitposOffset in next, scanDirections do
                    local hitpos = reverse * (hitposOffset * (hitRadius * 0.99))
                    local velocity, bulletTime = trajectory(firepos, acceleration, hitpos, bulletspeed)

                    if bulletCheck(firepos, hitpos, velocity, acceleration, penetrationdepth, raycastDelta) then
                        return firepos, hitpos, velocity, bulletTime
                    end
                end
            else
                local velocity, bulletTime = trajectory(firepos, acceleration, target, bulletspeed)

                if bulletCheck(firepos, target, velocity, acceleration, penetrationdepth, raycastDelta) then
                    return firepos, target, velocity, bulletTime
                end
            end
        end
    else
        local velocity, bulletTime = trajectory(origin, acceleration, target, bulletspeed)

        if bulletCheck(origin, target, velocity, acceleration, penetrationdepth, raycastDelta) then
            return origin, target, velocity, bulletTime
        end
    end
 
    return nil, nil, nil, nil
end

local function getTeleportPositions(origin, target)
    local cframe = CFrame.new(origin, target) * CFrame.Angles(0, 0, math.rad(math.random(0, 90)))
    local teleports = {}

    for _, offset in next, scanDirections do
        local distance = maxTeleportRadius * 0.99
        local newPos = cframe * (offset * distance)
        local hit, hitPos = raycast(origin, newPos - origin, physicsignore)

        if hit then
            newPos = hitPos - (newPos - origin).Unit
            distance = (origin - newPos).Magnitude
        end

        if distance > 1 then
            table.insert(teleports, {newPos, distance})
        end
    end

    return teleports
end

local function scanPosition(origin, target, bulletspeed, penetrationdepth)
    for scanIndex = 1, ragebotPositionScanCount do
        local firepos, hitpos, velocity, bulletTime = getFirePositions(origin, target, bulletspeed, penetrationdepth, fireposRadius, hitboxRadius)
        
        if firepos then
            return firepos, hitpos, velocity, bulletTime
        end
    end

    for scanIndex = 1, ragebotTeleportScanCount do
        local possibleOrigins = teleportScanning and getTeleportPositions(origin, target)
        if teleportScanning  then -- and possibleOrigins[1] then
            for _, originData in next, possibleOrigins do
                local newOrigin, distance = table.unpack(originData)
                local firepos, hitpos, velocity, bulletTime = getFirePositions(newOrigin, target, bulletspeed, penetrationdepth, teleportingFireposRadius, teleportingHitboxRadius) --, 8, 8)
                
                if firepos then
                    return firepos, hitpos, velocity, bulletTime, newOrigin, distance
                end
            end
        end
    end
end

local function simulateBullet(origin, velocity, penetration)
	local frames = {}
    local wallHits = {}
	local newTime = 0
	local newOrigin = origin
	local newVelocity = velocity
	local newPenetration = penetration
	local ignoreList = {table.unpack(physicsignore)}

	while (newTime < 2) do
		local frameTime = raycastDelta
		local motion = (frameTime * newVelocity) + (((frameTime * frameTime) / 2) * acceleration)
		local hit, enter = raycast(newOrigin, motion, ignoreList)

		if hit and hit.CanCollide and hit.Transparency ~= 1 and hit.Name ~= "Window" then
			local canShoot = false
			local normal = motion.unit
            local maxExtent = hit.Size.magnitude * normal
            local _, exit = raycast(enter + maxExtent, -maxExtent, {hit}, true)
            
			if exit then
                canShoot = true
				newPenetration = newPenetration - normal:Dot(exit - enter)

				if (newPenetration < 0) then
                    table.insert(frames, {newOrigin, enter})
                    table.insert(wallHits, enter)
					return frames, wallHits
				end
			else
				canShoot = true
			end

			if canShoot then
                table.insert(wallHits, exit)
                table.insert(wallHits, enter)
				table.insert(ignoreList, hit)
                table.insert(frames, {newOrigin, exit})
				local timePassed = (motion:Dot(enter - newOrigin) / motion:Dot(motion)) * frameTime
				newOrigin = enter + (0.01 * (newOrigin - enter).unit)
				newVelocity = newVelocity + (timePassed * acceleration)
				newTime = newTime + timePassed
			end
		else
            table.insert(frames, {newOrigin, newOrigin + motion})
			newOrigin = newOrigin + motion
			newVelocity = newVelocity + (frameTime * acceleration)
			newTime = newTime + frameTime
		end
	end

	return frames, wallHits
end

local function drawLine(origin, velocity, maxpenetrationdepth)
    if drawTrajectory then
        local frames = simulateBullet(origin, velocity, maxpenetrationdepth)

        local function fade(part)
            local timeDelay = lineFadeDuration / 15
            local transOffset = (1 - lineTransparency) / 15

            for _ = 1, 15 do
                part.Transparency += transOffset
                task.wait(timeDelay)
            end

            part:Destroy()
        end

        for frame = 1, #frames do
            local origin, target = table.unpack(frames[frame])
            local distance = (origin - target).Magnitude
            local tracer = Instance.new("Part")

            tracer.Material = Enum.Material[lineMaterial]
            tracer.Transparency = lineTransparency
            tracer.Anchored = true
            tracer.CanCollide = false
            tracer.Color = lineColor
            tracer.Size = Vector3.new(distance, lineThickness, lineThickness)
            tracer.Shape = Enum.PartType.Cylinder
            tracer.CFrame = (CFrame.new(origin, target) * CFrame.Angles(0, math.rad(90), 0)) * CFrame.new(Vector3.new(distance * 0.5, 0, 0))
            tracer.Parent = tracerFolder
            task.delay(lineDuration, fade, tracer)
        end
    end
end

local hitDetections = {}
local networkConnections = debug.getupvalue(getconnections(debug.getupvalue(network.send, 1).OnClientEvent)[1].Function, 1)
local updateothershealth = networkConnections.updateothershealth
function networkConnections.updateothershealth(player, health, time, alive)
    local realTime = network.getTime()
    
    for _, hitData in next, hitDetections do
        if not hitData.detected and player == hitData.player and realTime - hitData.time < 0.15 then
            hitData.detected = true
            break
        end
    end
    
    return updateothershealth(player, health, time, alive)
end

local debt = 0
local spawned = false
local currentTarget = nil
local updateAngles, updatePosition, lastTime
local recentUpdates = 0
local updatedAngles = false
local send = network.send
function network:send(name, ...)
    if name == "repupdate" then
        local position, angles, time = ...
        local newTime

        if updateAngles then
            position = updatePosition or position
            angles = Vector2.new(toanglesyx(updateAngles.Unit))
            recentUpdates = recentUpdates + 1

            if updatePosition then
                newTime = lastTime

                if updatedAngles then
                    return
                end

                send(self, name, updatePosition, angles, lastTime)
            end

            updatedAngles = true
        elseif debt > 0 then
            debt = debt - 1
            return
        end

        spawned = true
        lastTime = newTime or (time + currentAddition)
        return send(self, name, position, angles, lastTime)
    elseif name == "spawn" then
        lastTime = nil
        currentTarget = nil
        updatePosition = nil
        updateAngles = nil
        updatedAngles = false
        spawned = false
    elseif name == "ping" then
        local a, b, c = ...
        c = c + currentAddition
        return send(self, name, a, b, c)
    elseif timeUpdates[name] then
        local arguments = table.pack(...)
        local argIndex = timeUpdates[name]
        arguments[argIndex] = arguments[argIndex] + currentAddition
        return send(self, name, table.unpack(arguments))
    end

    return send(self, name, ...)
end

local lastUpdate = 0
local nextShoot = 0
local consecutiveShots = 0
local rageDelta = 1 / ragebotScanFPS
local allTeleports = nil
local heartbeat = runService.Heartbeat:Connect(function()
    local ticktime = tick()
    local rootPart = ignore:FindFirstChild("RefPlayer")
    local currentgun = weapon.getController(); currentgun = currentgun and currentgun._activeWeaponRegistry[currentgun._activeWeaponIndex]
    
    if ambient then
        lighting.OutdoorAmbient = ambientColor
        lighting.Ambient = ambientColor
    end

    if currentgun and currentgun._weaponData and currentgun._weaponData.bulletspeed and rootPart and rootPart:FindFirstChild("HumanoidRootPart") and not roundSystem.roundLock then
        rootPart = rootPart.HumanoidRootPart
        local unique = currentgun.uniqueId
        local origin = rootPart.Position
        local scanned = false
        local target, originPos, targetPos, velocity, time, newOrigin, distance

        if ticktime - lastUpdate > rageDelta then
            scanned = true
            lastUpdate = ticktime
            local closestNiggas = getClosestPlayers(origin)

            if closestNiggas then
                for nigga = 1, #closestNiggas do
                    local entry = closestNiggas[nigga]
                    local position = entry._receivedPosition --or entry._thirdPersonObject._characterHash.Head.Position -- remove for hitbox shifting
                    
                    if position then
                        local firepos, hitpos, velocity, bulletTime, bestOrigin, bestDistance = scanPosition(origin, position, currentgun._weaponData.bulletspeed, currentgun._weaponData.penetrationdepth)
                        
                        if firepos then
                            if currentTarget and currentTarget[1]._player ~= entry._player then
                                updatePosition = nil
                                updateAngles = nil
                                updatedAngles = false
                            end
                            currentTarget = {entry, firepos, hitpos, velocity, bulletTime, bestOrigin, bestDistance}
                            target, originPos, targetPos, velocity, time, newOrigin, distance = table.unpack(currentTarget)
                            break
                        end
                    end
                end
            end
        end

        if scanned then
            if not target and currentTarget then
                currentTarget = nil
                updatePosition = nil
                updateAngles = nil
                updatedAngles = false
            end
        elseif currentTarget then
            target, originPos, targetPos, velocity, time, newOrigin, distance = table.unpack(currentTarget)
        end

        if target and velocity then
            local speed = currentgun._weaponData.firerate
            speed = type(speed) == "table" and speed[currentgun._firemodeIndex] or speed
            local shootDelay = 60 / speed

            local netTime = network.getTime() + currentAddition
            --if netTime > nextShoot and not updateAngles then
            --    debt = debt + 1
            --    updateAngles = (targetPos - originPos).Unit
            --    updatedAngles = false
            --    recentUpdates = 0
            --    
            --    allTeleports = nil
            --    updatePosition = nil
            --    if newOrigin then
            --        --lastTime = network.getTime() + currentAddition
            --        --send(network, "repupdate", origin, Vector2.new(toanglesyx((targetPos - originPos).Unit)), lastTime)
            --        --updatePosition = origin + (newOrigin - origin) * 0.5
            --        --lastTime = network.getTime() + currentAddition
            --        send(network, "repupdate", origin + (newOrigin - origin) * 0.5, Vector2.new(toanglesyx((targetPos - originPos).Unit)), lastTime)
            --        --debt = debt + 1
            --        updatePosition = newOrigin
            --    end
            --
            --    --[[if newOrigin then
            --        local angles = Vector2.new(toanglesyx(updateAngles))
            --        local currentTime = network.getTime() + currentAddition
            --        allTeleports = {}
            --
            --        --send(network, "repupdate", origin, angles, currentTime)
            --        if distance > 9.9 then
            --            local firstPosition = origin + (newOrigin - origin).Unit * 9.9
            --            table.insert(allTeleports, firstPosition)
            --            send(network, "repupdate", firstPosition, angles, currentTime)
            --        else
            --            send(network, "repupdate", origin, angles, currentTime)
            --            table.insert(allTeleports, newOrigin)
            --        end
            --        
            --        send(network, "repupdate", newOrigin, angles, currentTime)
            --        workspace.Ignore.RefPlayer.HumanoidRootPart.Position = newOrigin
            --        updatePosition = newOrigin
            --        --origin = newOrigin
            --        table.insert(allTeleports, origin)
            --        --debt = debt + 2
            --        print(distance)
            --    end]]
            --end

            if netTime > nextShoot then--and updatedAngles then--and recentUpdates > 5 then
                --updateAngles = (targetPos - originPos).Unit
                local newAngles = (targetPos - originPos).Unit
                local angles = Vector2.new(toanglesyx(newAngles))
                updateAngles = nil
                updatePosition = nil

                local bulletsNeeded = 1
                if firerateBypass then
                    local health = (target._healthstate.health0 ~= 0 and target._healthstate.health0) or 100
                    local damage = weaponUtils.interpolateDamageGraph(currentgun:getWeaponStat("damageGraph"), (originPos - targetPos).Magnitude) * currentgun:getWeaponStat("multhead")
                    bulletsNeeded = math.ceil(health / damage)
                end

                
                --if newOrigin then
                --    --send(network, "repupdate", origin + (newOrigin - origin) * 0.5, angles, lastTime)
                --    --send(network, "repupdate", newOrigin, angles, lastTime)
                --    send(network, "repupdate", newOrigin + newAngles * 0.001, angles, network.getTime() + currentAddition)
                --    send(network, "repupdate", newOrigin + newAngles * 0.002, angles, network.getTime() + currentAddition)
                --    rootPart.Position = newOrigin
                --    print(distance)
                --    debt = debt + 2
                --else
                --    debt = debt + 2
                --    send(network, "repupdate", origin + newAngles * 0.001, angles, network.getTime() + currentAddition)
                --    send(network, "repupdate", origin + newAngles * 0.002, angles, network.getTime() + currentAddition)
                --end
                if newOrigin then
                    rootPart.Position = newOrigin
                    print("teleported", distance)
                end
                debt = debt + (newOrigin and 2 or 1)
                
                --local fireTime = network.getTime() + currentAddition
                --send(network, "repupdate", (newOrigin or origin) + newAngles * 0.001, angles, network.getTime() + currentAddition)
                --send(network, "repupdate", (newOrigin or origin) + newAngles * 0.001, angles, network.getTime() + currentAddition)
                local fireTime = network.getTime() + currentAddition
                --send(network, "repupdate", (newOrigin or origin), angles, fireTime)
                    --currentAddition = currentAddition + 0.5
                
                for i = 1, bulletsNeeded do
                    local bullets = {}

                    for bulletIndex = 1, currentgun._weaponData.pelletcount or 1 do
                        bullets[bulletIndex] = {velocity.Unit, bulletCount}
                        bulletCount = bulletCount + 1
                    end
                    --local firetime = network.getTime() + currentAddition
                    send(network, "newbullets", unique, {camerapos = newOrigin or origin, firepos = originPos, bullets = bullets}, fireTime)
                    drawLine(originPos, velocity, currentgun._weaponData.penetrationdepth)

                    currentAddition = currentAddition + time
                    if undetected then
                        for bulletIndex = 1, #bullets do
                            task.delay(time, function()
                                send(network, "bullethit", unique, target._player, targetPos, "Head", bullets[bulletIndex][2], network.getTime() + currentAddition)
                            end)
                        end
                    else
                        for bulletIndex = 1, #bullets do
                            send(network, "bullethit", unique, target._player, targetPos, "Head", bullets[bulletIndex][2], fireTime)
                        end
                    end
                    
                    if firerateBypass then
                        currentAddition = currentAddition + shootDelay
                    end
                end

                --[[if allTeleports then
                    local currentTime = network.getTime() + currentAddition
                    --send(network, "repupdate", newOrigin, angles, currentTime)
                    --debt = debt + 2

                    for posIndex = 1, #allTeleports do
                        send(network, "repupdate", allTeleports[posIndex], angles, currentTime)
                    end
                    --send(network, "repupdate", origin, angles, network.getTime() + currentAddition)
                end]]

                print("shot", target._player.Name, bulletsNeeded)
                nextShoot = network.getTime() + currentAddition + ((firerateBypass and fireDelayMS * 0.001) or shootDelay) + (undetected and time or 0)
                consecutiveShots = consecutiveShots + 1

                if consecutiveShots >= currentgun._weaponData.magsize then
                    send(network, "reload")
                    consecutiveShots = 0
                end

                if firerateBypass then
                shooting[target._player] = true
                end
                local hitData = {player = target._player, time = network.getTime()}
                table.insert(hitDetections, 1, hitData)
                task.delay(0.2, function()
                    shooting[hitData.player] = nil

                    if not hitData.detected then
                        print("miss detected on " .. hitData.player.Name)
                        ignoredPlayers[hitData.player] = true

                        task.delay(missCooldownMS * 0.001, function()
                            ignoredPlayers[hitData.player] = nil
                        end)
                    end
                end)
            end
        end
    end
end)


getgenv().unload = function()
    hudnotify.typeList.kill[1] = "Enemy Killed!"
    networkConnections.updateothershealth = updateothershealth
    network.send = send
    heartbeat:Disconnect()
    lighting.Ambient = Color3.new(0, 0, 0)
    lighting.OutdoorAmbient = Color3.new(0, 0, 0)

    return {
        currentAddition = currentAddition,
        bulletCount = bulletCount
    }
end
